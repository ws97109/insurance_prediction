---
name: 模型開發與訓練
status: open
created: 2025-10-09T02:52:41Z
updated: 2025-10-09T02:52:41Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: false
conflicts_with: []
---

# Task: 模型開發與訓練

## Description

開發並訓練三個機器學習模型：
1. **DQN (Deep Q-Network)** - 用於交叉銷售產品推薦
2. **XGBoost (備案)** - 用於交叉銷售產品推薦 (若 DQN 效果不佳)
3. **XGBoost (分群)** - 用於客戶價值分群 (高/中/低)

並行開發 DQN 與 XGBoost 交叉銷售模型，Week 6 結束前評估並選擇最佳方案。使用 MLflow 追蹤所有實驗與模型版本。

## Acceptance Criteria

### DQN 模型
- [ ] DQN 網路架構實作完成：
  - 輸入層: 86 維特徵向量
  - 隱藏層: 3 層全連接 (256-128-64 神經元)
  - 輸出層: 10-15 個保險產品 (動作空間)
- [ ] Experience Replay 機制實作完成 (Replay Buffer 容量 ≥ 10000)
- [ ] Target Network 實作完成 (每 100 步更新一次)
- [ ] ε-greedy 探索策略實作 (ε 從 1.0 衰減至 0.01)
- [ ] 獎勵函數定義完成 (購買=+1, 未購買=-0.1)
- [ ] DQN 模型訓練完成，準確率 ≥ 75% (測試集)
- [ ] 模型檔案儲存為 `.h5` 格式

### XGBoost 交叉銷售模型 (備案)
- [ ] XGBoost 多分類模型訓練完成
- [ ] 超參數調整完成 (GridSearchCV / Optuna)
- [ ] 模型準確率 ≥ 75% (測試集)
- [ ] 模型檔案儲存為 `.pkl` 格式

### XGBoost 客戶分群模型
- [ ] 定義客戶分群標籤 (基於保險持有價值)：
  - 高價值: score > 70
  - 中價值: 30 ≤ score ≤ 70
  - 低價值: score < 30
- [ ] XGBoost 分群模型訓練完成
- [ ] 模型準確率 ≥ 85% (測試集)
- [ ] 特徵重要性分析完成
- [ ] 模型檔案儲存為 `.pkl` 格式

### 模型評估
- [ ] 產出模型效能報告，包含：
  - 準確率 (Accuracy)
  - 精確率 (Precision)
  - 召回率 (Recall)
  - F1 Score
  - 混淆矩陣 (Confusion Matrix)
  - ROC-AUC (若適用)
- [ ] DQN vs XGBoost 交叉銷售模型對比報告
- [ ] 最終模型選擇決策文件

### MLflow 實驗追蹤
- [ ] 所有實驗已記錄至 MLflow
- [ ] 模型參數、指標、產物已完整追蹤
- [ ] 最佳模型已註冊至 MLflow Model Registry

## Technical Details

### DQN 實作 (TensorFlow / PyTorch)

#### 網路架構
```python
import tensorflow as tf

class DQN(tf.keras.Model):
    def __init__(self, state_dim=86, action_dim=15):
        super(DQN, self).__init__()
        self.fc1 = tf.keras.layers.Dense(256, activation='relu')
        self.fc2 = tf.keras.layers.Dense(128, activation='relu')
        self.fc3 = tf.keras.layers.Dense(64, activation='relu')
        self.output_layer = tf.keras.layers.Dense(action_dim)

    def call(self, state):
        x = self.fc1(state)
        x = self.fc2(x)
        x = self.fc3(x)
        return self.output_layer(x)
```

#### Experience Replay
```python
from collections import deque
import random

class ReplayBuffer:
    def __init__(self, capacity=10000):
        self.buffer = deque(maxlen=capacity)

    def add(self, state, action, reward, next_state, done):
        self.buffer.append((state, action, reward, next_state, done))

    def sample(self, batch_size=32):
        return random.sample(self.buffer, batch_size)
```

#### 訓練迴圈
```python
def train_dqn(model, target_model, replay_buffer, optimizer):
    batch = replay_buffer.sample(batch_size=32)
    states, actions, rewards, next_states, dones = zip(*batch)

    # Compute target Q-values
    target_q_values = target_model(next_states)
    targets = rewards + gamma * tf.reduce_max(target_q_values, axis=1) * (1 - dones)

    # Update model
    with tf.GradientTape() as tape:
        q_values = model(states)
        q_action = tf.reduce_sum(q_values * tf.one_hot(actions, action_dim), axis=1)
        loss = tf.reduce_mean((targets - q_action) ** 2)

    gradients = tape.gradient(loss, model.trainable_variables)
    optimizer.apply_gradients(zip(gradients, model.trainable_variables))
```

### XGBoost 實作

#### 交叉銷售模型
```python
import xgboost as xgb
from sklearn.model_selection import GridSearchCV

# 定義參數網格
param_grid = {
    'max_depth': [3, 5, 7],
    'learning_rate': [0.01, 0.1, 0.3],
    'n_estimators': [100, 200, 300],
    'subsample': [0.8, 1.0],
}

xgb_model = xgb.XGBClassifier(objective='multi:softmax', num_class=15)
grid_search = GridSearchCV(xgb_model, param_grid, cv=5, scoring='accuracy')
grid_search.fit(X_train, y_train)

best_model = grid_search.best_estimator_
```

#### 客戶分群模型
```python
# 定義分群標籤 (基於客戶保險價值評分)
def create_segment_labels(df):
    # 計算客戶價值評分 (範例邏輯)
    df['value_score'] = df[product_cols].sum(axis=1) * df['purchasing_power']

    # 分群
    df['segment'] = pd.cut(df['value_score'],
                           bins=[0, 30, 70, 100],
                           labels=['low', 'medium', 'high'])
    return df

# 訓練分群模型
xgb_segment = xgb.XGBClassifier(objective='multi:softmax', num_class=3)
xgb_segment.fit(X_train, y_segment_train)
```

### MLflow 整合
```python
import mlflow
import mlflow.tensorflow
import mlflow.xgboost

with mlflow.start_run(run_name="DQN_CrossSell"):
    # 記錄參數
    mlflow.log_param("learning_rate", 0.001)
    mlflow.log_param("gamma", 0.99)
    mlflow.log_param("epsilon_decay", 0.995)

    # 訓練模型
    train_dqn(...)

    # 記錄指標
    mlflow.log_metric("accuracy", accuracy)
    mlflow.log_metric("precision", precision)

    # 記錄模型
    mlflow.tensorflow.log_model(dqn_model, "dqn_model")
```

### 檔案位置
- **DQN Notebook**: `notebooks/02_dqn_training.ipynb`
- **XGBoost Notebook**: `notebooks/03_xgboost_training.ipynb`
- **模型檔案**:
  - `models/dqn_model.h5` (或 `dqn_model.pt`)
  - `models/xgb_crosssell.pkl`
  - `models/xgb_segment.pkl`
- **評估報告**: `reports/model_evaluation.md`

### 風險與挑戰
1. **DQN 訓練不穩定**: 可能需要調整超參數或網路架構
2. **過擬合風險**: 使用 Dropout、Early Stopping 緩解
3. **類別不平衡**: 使用 Class Weight 或 SMOTE
4. **GPU 資源不足**: 備案使用 Google Colab / Kaggle Kernel

## Dependencies

### 外部依賴
- [ ] Task 001 完成 (清洗後的訓練/測試資料)
- [ ] Python 環境已安裝相關套件：
  - TensorFlow >= 2.8.0 或 PyTorch >= 1.12.0
  - XGBoost >= 1.5.0
  - scikit-learn >= 1.0.0
  - MLflow >= 1.30.0
  - optuna >= 3.0.0 (若使用 Optuna 調參)

### 內部依賴
- [ ] 需要 GPU 資源 (本地或雲端)
- [ ] MLflow Tracking Server 已啟動

## Effort Estimate

- **規模**: L (大型)
- **預估時數**: 120 小時 (6 週，每週 20 小時)
  - DQN 開發: 40 小時
  - XGBoost 交叉銷售: 20 小時
  - XGBoost 客戶分群: 20 小時
  - 超參數調整: 20 小時
  - 模型評估與選擇: 12 小時
  - 文件撰寫: 8 小時
- **可並行**: false (依賴 Task 001 完成)

## Definition of Done

- [x] DQN 模型訓練完成，測試集準確率 ≥ 75% (或已決定採用 XGBoost 備案)
- [x] XGBoost 客戶分群模型準確率 ≥ 85%
- [x] 所有模型檔案已儲存至 `models/` 目錄
- [x] MLflow 實驗追蹤完整記錄
- [x] 模型效能報告已產出 (包含混淆矩陣、ROC-AUC 等)
- [x] 最終模型選擇決策已文件化
- [x] Code Review 完成
- [x] 模型可重現訓練 (Reproducibility: 固定 random seed)
