---
name: 整合測試與優化
status: open
created: 2025-10-09T02:52:41Z
updated: 2025-10-09T02:52:41Z
github: [Will be updated when synced to GitHub]
depends_on: [003, 004]
parallel: false
conflicts_with: []
---

# Task: 整合測試與優化

## Description

執行端到端整合測試,驗證前後端整合、API 功能、資料流程的正確性。進行效能測試與優化,確保系統符合效能目標 (單筆預測 < 3 秒、頁面載入 < 2 秒)。建立 Docker Compose 配置,統一開發、測試、生產環境。

**測試範圍**:
- 端到端 (E2E) 整合測試
- API 效能測試 (負載測試)
- 前端效能優化
- Docker 容器化

## Acceptance Criteria

### 整合測試
- [ ] E2E 測試覆蓋關鍵使用者流程:
  - 使用者登入 → 查詢客戶推薦 → 查看結果
  - 使用者登入 → 上傳批量預測 → 下載結果
  - 使用者登入 → 查看儀表板 → 篩選資料 → 匯出 CSV
- [ ] API 整合測試覆蓋所有端點
- [ ] 資料庫整合測試 (CRUD 操作)
- [ ] Redis 快取測試 (命中率、TTL)

### 效能測試
- [ ] API 效能測試 (Locust / JMeter):
  - 50 並發使用者
  - 單筆預測回應時間 < 3 秒 (95th percentile)
  - 批量預測 (500 筆) < 10 分鐘
- [ ] 前端效能測試 (Lighthouse):
  - 頁面載入時間 < 2 秒
  - 首次內容繪製 (FCP) < 1.5 秒
  - 累積版面配置位移 (CLS) < 0.1
- [ ] 資料庫查詢效能優化 (索引建立)

### 效能優化
- [ ] 後端優化:
  - 模型推論速度優化
  - 資料庫查詢最佳化 (索引、查詢計畫)
  - Redis 快取策略調整
  - API 回應壓縮 (gzip)
- [ ] 前端優化:
  - 程式碼分割 (Code Splitting)
  - 圖片/資源懶載入 (Lazy Loading)
  - 快取策略 (Service Worker / Cache-Control)

### Docker 容器化
- [ ] Dockerfile 建立:
  - 後端 Dockerfile (多階段建構)
  - 前端 Dockerfile (Nginx 靜態檔案服務)
- [ ] Docker Compose 配置完成:
  - app (FastAPI)
  - frontend (React + Nginx)
  - db (PostgreSQL)
  - redis (Redis)
- [ ] 環境變數管理 (.env 檔案)
- [ ] Docker 健康檢查 (healthcheck)
- [ ] 本地開發環境啟動流程文件化

### Bug 修正
- [ ] 所有已知 Bug 已修正
- [ ] 邊界情況處理 (空輸入、異常資料)
- [ ] 錯誤處理與日誌記錄完善

## Technical Details

### E2E 測試 (Playwright / Cypress)

```javascript
// e2e/tests/recommendation.spec.js
import { test, expect } from '@playwright/test';

test('使用者查詢客戶推薦流程', async ({ page }) => {
  // 登入
  await page.goto('http://localhost:3000/login');
  await page.fill('input[name="username"]', 'testuser');
  await page.fill('input[name="password"]', 'testpass');
  await page.click('button[type="submit"]');

  // 導航至推薦頁面
  await page.goto('http://localhost:3000/recommendation');

  // 輸入客戶 ID
  await page.fill('input[placeholder="輸入客戶 ID"]', 'CUST12345');

  // 等待結果載入
  await page.waitForSelector('.recommendation-card', { timeout: 5000 });

  // 驗證 Top 3 推薦顯示
  const recommendations = await page.$$('.recommendation-card');
  expect(recommendations.length).toBe(3);

  // 驗證推薦產品包含機率
  const firstRec = await recommendations[0].textContent();
  expect(firstRec).toContain('%');
});
```

### API 效能測試 (Locust)

```python
# locustfile.py
from locust import HttpUser, task, between

class InsuranceUser(HttpUser):
    wait_time = between(1, 3)

    def on_start(self):
        # 登入取得 Token
        response = self.client.post("/api/v1/auth/login", json={
            "username": "testuser",
            "password": "testpass"
        })
        self.token = response.json()["access_token"]
        self.headers = {"Authorization": f"Bearer {self.token}"}

    @task(3)
    def predict_single(self):
        self.client.post("/api/v1/predict/single",
            json={
                "customer_id": "CUST12345",
                "features": [0.1] * 86  # 86 維特徵向量
            },
            headers=self.headers
        )

    @task(1)
    def get_segment(self):
        self.client.post("/api/v1/segment",
            json={
                "customer_id": "CUST12345",
                "features": [0.1] * 86
            },
            headers=self.headers
        )
```

執行測試:
```bash
locust -f locustfile.py --host=http://localhost:8000 --users=50 --spawn-rate=10
```

### Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:13-alpine
    environment:
      POSTGRES_DB: insurance
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql://${DB_USER}:${DB_PASSWORD}@db:5432/insurance
      REDIS_URL: redis://redis:6379
      JWT_SECRET: ${JWT_SECRET}
    volumes:
      - ./models:/app/models
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    depends_on:
      - backend
    environment:
      REACT_APP_API_URL: http://localhost:8000

volumes:
  postgres_data:
```

### 後端 Dockerfile (多階段建構)

```dockerfile
# backend/Dockerfile
FROM python:3.10-slim as builder

WORKDIR /app

# 安裝依賴
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 複製程式碼
COPY . .

# 生產環境
FROM python:3.10-slim

WORKDIR /app

COPY --from=builder /usr/local/lib/python3.10/site-packages /usr/local/lib/python3.10/site-packages
COPY --from=builder /app /app

# 健康檢查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 前端 Dockerfile (Nginx)

```dockerfile
# frontend/Dockerfile
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Nginx 靜態檔案服務
FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 效能優化策略

#### 後端優化
1. **資料庫索引**:
```sql
CREATE INDEX idx_customer_id ON customers(customer_id);
CREATE INDEX idx_predicted_at ON predictions(predicted_at);
CREATE INDEX idx_segment ON segments(segment);
```

2. **Redis 快取預熱**:
```python
# 預先載入常用客戶的預測結果
def warm_cache():
    top_customers = get_top_1000_customers()
    for customer in top_customers:
        predict_and_cache(customer.id)
```

#### 前端優化
1. **程式碼分割**:
```javascript
// 使用 React.lazy 進行路由層級分割
const Dashboard = React.lazy(() => import('./pages/Dashboard'));
const Recommendation = React.lazy(() => import('./pages/Recommendation'));
```

2. **圖表效能優化**:
```javascript
// 使用 useMemo 避免重複渲染
const chartData = useMemo(() => ({
  labels: data.labels,
  datasets: data.datasets
}), [data]);
```

### 檔案位置
- **E2E 測試**: `e2e/tests/`
- **效能測試**: `performance/locustfile.py`
- **Docker 配置**: 根目錄 `docker-compose.yml`
- **測試報告**: `reports/integration_test_report.md`

## Dependencies

### 外部依賴
- [ ] Task 003 完成 (後端 API)
- [ ] Task 004 完成 (前端應用)
- [ ] 測試工具安裝:
  - Playwright >= 1.30.0 或 Cypress >= 12.0
  - Locust >= 2.14.0
  - Docker >= 20.10
  - Docker Compose >= 2.0

### 內部依賴
- [ ] 測試環境資料庫已準備
- [ ] 測試用戶帳號已建立

## Effort Estimate

- **規模**: M (中型)
- **預估時數**: 40 小時 (2 週,每週 20 小時)
  - E2E 測試撰寫: 12 小時
  - 效能測試與優化: 12 小時
  - Docker 容器化: 8 小時
  - Bug 修正: 8 小時
- **可並行**: false (依賴前後端完成)

## Definition of Done

- [x] E2E 測試通過率 100%
- [x] API 效能測試達標 (50 並發, < 3 秒回應)
- [x] 前端 Lighthouse 分數 ≥ 90
- [x] Docker Compose 可一鍵啟動完整系統
- [x] 所有已知 Bug 已修正
- [x] 效能優化完成,符合所有效能目標
- [x] 整合測試報告已產出
- [x] 部署指南文件已更新
